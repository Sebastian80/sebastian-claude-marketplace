#!/usr/bin/env python3
"""
Serena CLI - Professional LSP-powered code intelligence

Usage:
    serena <command> [options]

Commands:
    activate    Activate a project (defaults to current directory)
    projects    List registered projects
    find        Find symbols by name pattern
    refs        Find all references to a symbol
    overview    Get file/class structure
    search      Search code with regex patterns
    memory      Memory operations (list, read, write, delete)
    edit        Symbol-based code editing
    recipe      Common pre-built operations
    tools       List available Serena tools
    status      Check Serena connection status

Search Strategy (3-Strike Rule):
    1. Start BROAD: serena find Payment
    2. If too many: serena find Payment --kind class
    3. If still none: serena find Pay --path src/
    → After 3 fails: fall back to grep

Language-Specific Patterns:
    PHP:     serena find Customer --kind class --path src/
             serena find Interface --kind interface
             serena refs "Entity/getId" src/Entity.php

    JS/TS:   serena find View --kind class --path "*/Resources/public/js/"
             serena find initialize --kind method

    YAML:    serena find payment_method (service key names)
             serena search "tags:.*kernel.event" --glob "*.yml"

Indexing Note:
    LSP indexes src/ before vendor/. During initial indexing:
    - Use --path src/ for faster results
    - vendor/ symbols appear after full indexing
    - If "No symbols found" → try broader pattern or use grep

Examples:
    serena activate                       Activate project in current directory
    serena find Customer --body           Find Customer class with body
    serena find Payment --kind interface  Find Payment interfaces
    serena find get --kind method --path src/Meyer/
    serena refs "Customer/getName" src/Entity/Customer.php
    serena recipe entities
    serena memory list
"""

import argparse
import json
import sys
import os
from datetime import datetime

# Add script directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from serena_client import SerenaClient, call


def parse_result(result):
    """Parse result that might be JSON string or already parsed."""
    if isinstance(result, str):
        try:
            return json.loads(result)
        except json.JSONDecodeError:
            return result
    return result


# =============================================================================
# Output Formatting
# =============================================================================

class Output:
    """Consistent output formatting."""

    def __init__(self, json_mode: bool = False):
        self.json_mode = json_mode

    def success(self, data):
        """Output successful result."""
        if self.json_mode:
            print(json.dumps(data, indent=2))
        elif isinstance(data, str):
            print(data)
        elif isinstance(data, list):
            for item in data:
                if isinstance(item, dict):
                    self._print_symbol(item)
                else:
                    print(f"  - {item}")
        elif isinstance(data, dict):
            print(json.dumps(data, indent=2))
        else:
            print(data)

    def error(self, message: str, hint: str = None):
        """Output error message."""
        if self.json_mode:
            print(json.dumps({"error": message, "hint": hint}), file=sys.stderr)
        else:
            print(f"Error: {message}", file=sys.stderr)
            if hint:
                print(f"Hint: {hint}", file=sys.stderr)
        sys.exit(1)

    def info(self, message: str):
        """Output info message (non-JSON only)."""
        if not self.json_mode:
            print(message, file=sys.stderr)

    def _print_symbol(self, sym: dict, indent: int = 0):
        """Pretty-print a symbol with line ranges and children."""
        kind_map = {
            3: "ns", 5: "class", 6: "method", 7: "prop",
            11: "iface", 12: "func", 13: "var", 14: "const",
            "Class": "class", "Method": "method", "Interface": "iface",
            "Function": "func", "Namespace": "ns", "Property": "prop",
            "Variable": "var", "Constant": "const"
        }
        kind = sym.get("kind", "?")
        kind_str = kind_map.get(kind, str(kind).lower() if isinstance(kind, str) else "?")
        name = sym.get("name_path", sym.get("name", "?"))
        path = sym.get("relative_path", "")
        loc = sym.get("body_location", {})
        start = loc.get("start_line", "?") if loc else "?"
        end = loc.get("end_line") if loc else None

        # Format line range
        line_str = f"{start}-{end}" if end and end != start else str(start)

        # Build prefix for indentation
        prefix = "  " * indent

        # Main symbol line: Name (kind) path:lines
        print(f"{prefix}{name} ({kind_str}) {path}:{line_str}")

        # Show body preview if present
        if "body" in sym and sym["body"]:
            body_lines = sym["body"].strip().split("\n")
            # Show first 3 lines of body
            for i, line in enumerate(body_lines[:3]):
                line_preview = line[:80] + ("..." if len(line) > 80 else "")
                print(f"{prefix}  {start + i}: {line_preview}")
            if len(body_lines) > 3:
                print(f"{prefix}  ... +{len(body_lines) - 3} more lines")

        # Show children if present (methods of a class)
        children = sym.get("children", [])
        if children:
            # Group by kind
            methods = [c for c in children if c.get("kind") in [6, "Method"]]
            props = [c for c in children if c.get("kind") in [7, "Property", "prop"]]
            others = [c for c in children if c not in methods and c not in props]

            if methods:
                shown = 0
                for child in methods[:5]:
                    c_name = child.get("name", child.get("name_path", "?"))
                    c_loc = child.get("body_location", {})
                    c_start = c_loc.get("start_line", "?")
                    c_end = c_loc.get("end_line")
                    c_line = f"{c_start}-{c_end}" if c_end else str(c_start)
                    connector = "├─" if shown < min(len(methods), 5) - 1 else "└─"
                    print(f"{prefix}  {connector} {c_name}() :{c_line}")
                    shown += 1
                if len(methods) > 5:
                    print(f"{prefix}     ... +{len(methods) - 5} more methods")
        print()


# =============================================================================
# Commands
# =============================================================================

def cmd_find(args, out: Output):
    """Find symbols by name pattern."""
    kwargs = {
        "name_path_pattern": args.pattern,
        "substring_matching": not args.exact,
        "include_body": args.body,
        "depth": args.depth
    }
    if args.path:
        kwargs["relative_path"] = args.path
    if args.kind:
        kind_map = {"class": 5, "method": 6, "interface": 11, "function": 12, "namespace": 3, "property": 7, "constant": 14}
        kinds = []
        for k in args.kind:
            k_lower = k.lower()
            if k_lower in kind_map:
                kinds.append(kind_map[k_lower])
            elif k.isdigit():
                kinds.append(int(k))
            else:
                print(f"Warning: Unknown kind '{k}', ignoring. Valid: {', '.join(kind_map.keys())}", file=sys.stderr)
        if kinds:
            kwargs["include_kinds"] = kinds

    result = parse_result(call("find_symbol", **kwargs))

    if not result:
        hints = []
        # Check if pattern seems too specific
        if len(args.pattern) > 15 or '\\' in args.pattern:
            hints.append(f"Pattern may be too specific - try shorter: '{args.pattern[:8]}...'")
        else:
            hints.append("Try a broader pattern (e.g., 'Payment' instead of 'PaymentMethodInterface')")

        # Suggest src/ path if searching vendor
        if args.path and 'vendor' in args.path:
            hints.append("vendor/ indexes slower - try --path src/ first")
        elif not args.path:
            hints.append("Try --path src/ (local code indexes before vendor/)")

        hints.append("LSP may still be indexing - wait or use grep as fallback")

        out.error(f"No symbols found matching '{args.pattern}'",
                  hint=" | ".join(hints[:2]))

    out.success(result)


def cmd_refs(args, out: Output):
    """Find all references to a symbol."""
    result = parse_result(call("find_referencing_symbols",
                  name_path=args.symbol,
                  relative_path=args.file))

    if not result:
        out.error(f"No references found for '{args.symbol}'",
                  hint="Verify the symbol exists with 'serena find'")

    # JSON mode - output as-is
    if out.json_mode:
        out.success(result)
        return

    # Human-readable format with context and truncation
    show_all = getattr(args, 'all', False)
    max_refs = len(result) if show_all else 10

    print(f"{len(result)} references to '{args.symbol}'\n")

    # Group by file for cleaner output
    by_file = {}
    for ref in result:
        path = ref.get("relative_path", "unknown")
        if path not in by_file:
            by_file[path] = []
        by_file[path].append(ref)

    shown_files = 0
    for path, refs in list(by_file.items())[:max_refs]:
        print(f"  {path}:")
        for ref in refs[:3]:  # Max 3 refs per file in summary
            loc = ref.get("body_location", {})
            line = loc.get("start_line", "?")
            ctx = ref.get("content_around_reference", "")
            # Extract the highlighted line (line with >)
            ctx_lines = [l.strip() for l in ctx.split('\n') if '>' in l[:5]]
            ctx_short = ctx_lines[0][4:64] if ctx_lines else ""  # Skip "> " prefix
            if ctx_short:
                print(f"    :{line}  {ctx_short}")
            else:
                print(f"    :{line}")
        if len(refs) > 3:
            print(f"    ... +{len(refs) - 3} more in this file")
        shown_files += 1

    remaining = len(by_file) - shown_files
    if remaining > 0:
        print(f"\n  ... +{remaining} more files (use --all to show all)")
    print()


def cmd_overview(args, out: Output):
    """Get overview of symbols in a file."""
    result = parse_result(call("get_symbols_overview", relative_path=args.file))

    # JSON mode - output as-is
    if out.json_mode:
        out.success(result)
        return

    if not result:
        out.error(f"No symbols found in '{args.file}'",
                  hint="Check file path or wait for LSP indexing")

    # Human-readable format grouped by kind
    kind_map = {
        3: "namespaces", 5: "classes", 6: "methods", 7: "properties",
        11: "interfaces", 12: "functions", 13: "variables", 14: "constants"
    }
    kind_order = [5, 11, 12, 6, 7, 14, 13, 3]  # classes, interfaces, funcs, methods...

    # Group symbols by kind
    by_kind = {}
    for sym in result:
        kind = sym.get("kind", 0)
        if kind not in by_kind:
            by_kind[kind] = []
        by_kind[kind].append(sym)

    print(f"{args.file} ({len(result)} symbols)\n")

    for kind in kind_order:
        if kind not in by_kind:
            continue
        symbols = by_kind[kind]
        kind_name = kind_map.get(kind, f"kind_{kind}")

        # For classes/interfaces, show with line numbers
        if kind in [5, 11]:
            print(f"  {kind_name.upper()}:")
            for sym in symbols:
                name = sym.get("name_path", sym.get("name", "?"))
                loc = sym.get("body_location", {})
                start = loc.get("start_line", "?")
                end = loc.get("end_line", "")
                line_str = f":{start}-{end}" if end else f":{start}" if start != "?" else ""
                print(f"    {name}{line_str}")
        # For functions, show names
        elif kind == 12:
            print(f"  {kind_name.upper()}:")
            for sym in symbols[:10]:
                name = sym.get("name_path", sym.get("name", "?"))
                loc = sym.get("body_location", {})
                line = loc.get("start_line", "?")
                print(f"    {name}() :{line}")
            if len(symbols) > 10:
                print(f"    ... +{len(symbols) - 10} more")
        # For constants/variables, compact list
        elif kind in [13, 14]:
            names = [sym.get("name_path", sym.get("name", "?")) for sym in symbols[:8]]
            extra = f" +{len(symbols) - 8}" if len(symbols) > 8 else ""
            print(f"  {kind_name.upper()}: {', '.join(names)}{extra}")
    print()


def cmd_search(args, out: Output):
    """Search for regex pattern in code."""
    kwargs = {"substring_pattern": args.pattern}
    if args.glob:
        kwargs["paths_include_glob"] = args.glob

    result = parse_result(call("search_for_pattern", **kwargs))

    if not result:
        out.error(f"No matches for pattern '{args.pattern}'",
                  hint="Check regex syntax or try a different glob")

    # JSON mode - output as-is
    if out.json_mode:
        out.success(result)
        return

    # Human-readable format grouped by file
    if isinstance(result, dict):
        total_matches = sum(len(v) for v in result.values())
        glob_str = f" in {args.glob}" if args.glob else ""
        print(f"Pattern: '{args.pattern}'{glob_str}")
        print(f"Found {total_matches} matches in {len(result)} files\n")

        for path, matches in list(result.items())[:15]:
            print(f"  {path}:")
            for match in matches[:5]:
                # Extract line number if present in format "  123: code"
                match_clean = match.strip()
                print(f"    {match_clean[:80]}")
            if len(matches) > 5:
                print(f"    ... +{len(matches) - 5} more matches")
        if len(result) > 15:
            print(f"\n  ... +{len(result) - 15} more files")
        print()
    else:
        out.success(result)


def cmd_memory(args, out: Output):
    """Memory operations with folder support."""
    if args.memory_cmd == "list":
        # Support optional folder filter and recursive flag
        kwargs = {}
        if hasattr(args, 'folder') and args.folder:
            kwargs['folder'] = args.folder
        if hasattr(args, 'no_recursive') and args.no_recursive:
            kwargs['recursive'] = False
        result = call("list_memories", **kwargs)
        if isinstance(result, str):
            result = json.loads(result)
        out.success(result)

    elif args.memory_cmd == "read":
        result = call("read_memory", memory_file_name=args.name)
        out.success(result)

    elif args.memory_cmd == "write":
        content = args.content
        if content == "-":
            content = sys.stdin.read()
        # Auto-add timestamp unless --no-timestamp flag is set
        if not getattr(args, 'no_timestamp', False):
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            # Append timestamp as HTML comment at the end (invisible in rendered markdown)
            content = f"{content}\n\n<!-- Updated: {timestamp} -->"
        result = call("write_memory", memory_file_name=args.name, content=content)
        out.info(f"Memory '{args.name}' written successfully")
        out.success(result)

    elif args.memory_cmd == "delete":
        result = call("delete_memory", memory_file_name=args.name)
        out.info(f"Memory '{args.name}' deleted")
        out.success(result)

    elif args.memory_cmd == "tree":
        kwargs = {}
        if hasattr(args, 'folder') and args.folder:
            kwargs['folder'] = args.folder
        result = call("tree_memories", **kwargs)
        out.success(result)

    elif args.memory_cmd == "search":
        kwargs = {"pattern": args.pattern}
        if hasattr(args, 'folder') and args.folder:
            kwargs['folder'] = args.folder
        result = call("search_memories", **kwargs)
        if isinstance(result, str):
            result = json.loads(result)
        # Pretty-print search results
        if out.json_mode:
            out.success(result)
        else:
            if not result:
                print("No matches found.")
            else:
                print(f"Found matches in {len(result)} memories:\n")
                for match in result:
                    print(f"  {match['memory']} ({match['matches']} matches)")
                    for snippet in match.get('snippets', [])[:2]:
                        snippet_clean = snippet.strip()[:60]
                        print(f"    ...{snippet_clean}...")
                    print()

    elif args.memory_cmd == "archive":
        kwargs = {"memory_file_name": args.name}
        if hasattr(args, 'category') and args.category:
            kwargs['category'] = args.category
        result = call("archive_memory", **kwargs)
        out.info(f"Memory '{args.name}' archived")
        out.success(result)

    elif args.memory_cmd == "mv":
        result = call("move_memory", source=args.source, dest=args.dest)
        out.info(f"Memory moved: '{args.source}' -> '{args.dest}'")
        out.success(result)

    elif args.memory_cmd == "init":
        include_templates = not getattr(args, 'no_templates', False)
        result = call("init_memories", include_templates=include_templates)
        out.success(result)

    elif args.memory_cmd == "stats":
        result = call("memory_stats")
        if isinstance(result, str):
            result = json.loads(result)
        if out.json_mode:
            out.success(result)
        else:
            print("Memory Statistics:\n")
            print(f"  Total memories: {result.get('total_count', 0)}")
            print(f"  Total size: {result.get('total_size_human', 'N/A')}")
            print(f"\n  By folder:")
            for folder, info in result.get('by_folder', {}).items():
                folder_display = folder if folder else "(root)"
                print(f"    {folder_display}: {info['count']} memories, {info['size_human']}")


def cmd_edit(args, out: Output):
    """Symbol-based code editing."""
    if args.edit_cmd == "replace":
        body = args.body
        if body == "-":
            body = sys.stdin.read()
        result = call("replace_symbol_body",
                      name_path=args.symbol,
                      relative_path=args.file,
                      body=body)

    elif args.edit_cmd == "after":
        body = args.body
        if body == "-":
            body = sys.stdin.read()
        result = call("insert_after_symbol",
                      name_path=args.symbol,
                      relative_path=args.file,
                      body=body)

    elif args.edit_cmd == "before":
        body = args.body
        if body == "-":
            body = sys.stdin.read()
        result = call("insert_before_symbol",
                      name_path=args.symbol,
                      relative_path=args.file,
                      body=body)

    elif args.edit_cmd == "rename":
        result = call("rename_symbol",
                      name_path=args.symbol,
                      relative_path=args.file,
                      new_name=args.new_name)

    out.success(result)


def cmd_recipe(args, out: Output):
    """Pre-built recipes for common operations."""
    recipes = {
        "entities": recipe_entities,
        "controllers": recipe_controllers,
        "services": recipe_services,
        "interfaces": recipe_interfaces,
        "tests": recipe_tests,
        "listeners": recipe_listeners,
        "commands": recipe_commands,
    }

    if args.recipe_name == "list":
        print("Available recipes:")
        for name, func in recipes.items():
            print(f"  {name:15} - {func.__doc__}")
        return

    if args.recipe_name not in recipes:
        out.error(f"Unknown recipe: {args.recipe_name}",
                  hint=f"Available: {', '.join(recipes.keys())}")

    recipes[args.recipe_name](args, out)


def recipe_entities(args, out: Output):
    """Find all Doctrine entities (ORM\\Entity attribute)"""
    # Search for ORM\Entity attribute (PHP 8 style)
    result = parse_result(call("search_for_pattern",
                  substring_pattern=r"#\[ORM\\Entity",
                  paths_include_glob="src/**/*.php"))

    if result and isinstance(result, dict):
        out.info(f"Found {len(result)} entity files:")
        out.success(result)
    else:
        # Try annotation style
        result = parse_result(call("search_for_pattern",
                      substring_pattern=r"@ORM\\Entity",
                      paths_include_glob="src/**/*.php"))
        if result and isinstance(result, dict):
            out.success(result)
        else:
            out.error("No entities found",
                      hint="Project may use different entity patterns")


def recipe_controllers(args, out: Output):
    """Find all controller classes"""
    result = parse_result(call("find_symbol",
                  name_path_pattern="Controller",
                  substring_matching=True,
                  include_kinds=[5],  # Classes only
                  depth=0))

    # Filter to only classes ending with Controller
    if result and isinstance(result, list):
        result = [s for s in result if s.get("name_path", "").endswith("Controller")]

    if result:
        out.info(f"Found {len(result)} controllers:")
        out.success(result)
    else:
        out.error("No controllers found")


def recipe_services(args, out: Output):
    """Find all service classes"""
    result = parse_result(call("find_symbol",
                  name_path_pattern="Service",
                  substring_matching=True,
                  include_kinds=[5],
                  depth=0))

    if result and isinstance(result, list):
        result = [s for s in result if "Service" in s.get("name_path", "")]
        out.info(f"Found {len(result)} services:")
        out.success(result)
    else:
        out.error("No services found")


def recipe_interfaces(args, out: Output):
    """Find all interfaces"""
    result = parse_result(call("find_symbol",
                  name_path_pattern="Interface",
                  substring_matching=True,
                  include_kinds=[11],
                  depth=0))

    if result and isinstance(result, list):
        out.info(f"Found {len(result)} interfaces:")
        out.success(result)
    else:
        out.error("No interfaces found")


def recipe_tests(args, out: Output):
    """Find all test classes"""
    result = parse_result(call("find_symbol",
                  name_path_pattern="Test",
                  substring_matching=True,
                  include_kinds=[5],
                  depth=0))

    if result and isinstance(result, list):
        result = [s for s in result if s.get("name_path", "").endswith("Test")]
        out.info(f"Found {len(result)} test classes:")
        out.success(result)
    else:
        out.error("No test classes found")


def recipe_listeners(args, out: Output):
    """Find all event listeners"""
    result = parse_result(call("find_symbol",
                  name_path_pattern="Listener",
                  substring_matching=True,
                  include_kinds=[5],
                  depth=0))

    if result and isinstance(result, list):
        out.info(f"Found {len(result)} listeners:")
        out.success(result)
    else:
        out.error("No listeners found")


def recipe_commands(args, out: Output):
    """Find all console commands"""
    result = parse_result(call("find_symbol",
                  name_path_pattern="Command",
                  substring_matching=True,
                  include_kinds=[5],
                  depth=0))

    if result and isinstance(result, list):
        result = [s for s in result if s.get("name_path", "").endswith("Command")]
        out.info(f"Found {len(result)} commands:")
        out.success(result)
    else:
        out.error("No commands found")


def cmd_tools(args, out: Output):
    """List available Serena tools."""
    client = SerenaClient()
    tools = client.list_tools()

    if args.json:
        out.success(tools)
    else:
        print("Available Serena tools:")
        for tool in tools:
            name = tool.get("name", "?")
            desc = tool.get("description", "")[:60]
            print(f"  {name:30} {desc}")


def cmd_status(args, out: Output):
    """Check Serena connection status."""
    try:
        result = call("get_current_config")
        out.info("Serena is connected and ready")
        out.success(result)
    except Exception as e:
        out.error(f"Cannot connect to Serena: {e}",
                  hint="Is Serena server running? Check SERENA_URL env var.")


def cmd_activate(args, out: Output):
    """Activate a project by path or name."""
    import os

    # Default to current working directory if no path given
    project = args.project if args.project else os.getcwd()

    # Resolve relative paths
    if os.path.exists(project) or project.startswith('/') or project.startswith('.'):
        project = os.path.abspath(project)

    try:
        result = call("activate_project", project=project)
        out.success(result)
    except Exception as e:
        error_msg = str(e)
        if "ProjectNotFoundError" in error_msg:
            out.error(f"Project not found: {project}",
                      hint="Use 'serena projects' to list registered projects, or provide a valid path")
        else:
            out.error(f"Failed to activate project: {e}")


def cmd_projects(args, out: Output):
    """List registered projects."""
    try:
        result = call("get_current_config")
        if isinstance(result, str):
            # Parse the text output to extract project info
            lines = result.split('\n')
            active_project = None
            available_projects = []
            in_projects_section = False

            for line in lines:
                if line.startswith("Active project:"):
                    active_project = line.split(":", 1)[1].strip()
                    if active_project and active_project not in available_projects:
                        available_projects.append(active_project)
                elif line.startswith("Available projects:"):
                    in_projects_section = True
                elif in_projects_section:
                    if line.startswith("Active context:") or line.startswith("Active modes:"):
                        break
                    proj = line.strip()
                    if proj and proj not in available_projects:
                        available_projects.append(proj)

            if args.json:
                out.success({
                    "active": active_project,
                    "projects": available_projects
                })
            else:
                if not available_projects:
                    print("No projects active.")
                    print(f"\nUse 'serena activate' to activate current directory")
                    print(f"Or:  'serena activate /path/to/project'")
                else:
                    print("Projects:")
                    for proj in available_projects:
                        marker = " (active)" if proj == active_project else ""
                        print(f"  {proj}{marker}")
        else:
            out.success(result)
    except Exception as e:
        out.error(f"Failed to list projects: {e}")


# =============================================================================
# Main
# =============================================================================

def main():
    parser = argparse.ArgumentParser(
        prog="serena",
        description="LSP-powered code intelligence (PHP, JS/TS, YAML, Markdown)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Search Strategy (3-Strike Rule):
  1. Start BROAD:     serena find Payment
  2. Add filters:     serena find Payment --kind class
  3. Restrict path:   serena find Payment --path src/
  → After 3 fails, use grep (LSP may still be indexing)

Language Examples:
  PHP:    serena find Customer --kind class --body
          serena refs "Entity/getId" src/Entity/Entity.php
  JS/TS:  serena find View --kind class --path "**/public/js/"
  YAML:   serena find payment_method
          serena search "tags:.*event" --glob "*.yml"

Common Commands:
  serena find Customer --body          Find class with implementation
  serena find "get*" --kind method     Find methods starting with 'get'
  serena refs Order/save src/Order.php Find who calls Order::save()
  serena recipe entities               Find all Doctrine entities
  serena memory list                   List saved memories
  serena status                        Check connection

Note: LSP indexes src/ before vendor/. Use --path src/ for faster results.
        """
    )
    parser.add_argument("--json", "-j", action="store_true",
                        help="Output in JSON format")

    subparsers = parser.add_subparsers(dest="command", help="Command to run")

    # find
    p_find = subparsers.add_parser("find", help="Find symbols by pattern")
    p_find.add_argument("pattern", help="Symbol name/pattern to find")
    p_find.add_argument("--path", "-p", help="Restrict to path")
    p_find.add_argument("--body", "-b", action="store_true", help="Include body code")
    p_find.add_argument("--depth", "-d", type=int, default=0, help="Traversal depth")
    p_find.add_argument("--kind", "-k", nargs="+",
                        help="Filter by kind: class, method, interface, function")
    p_find.add_argument("--exact", "-e", action="store_true", help="Exact match only")

    # refs
    p_refs = subparsers.add_parser("refs", help="Find references to symbol")
    p_refs.add_argument("symbol", help="Symbol path (e.g., Customer/getName)")
    p_refs.add_argument("file", help="File where symbol is defined")
    p_refs.add_argument("--all", "-a", action="store_true", help="Show all references (default: top 10 files)")

    # overview
    p_overview = subparsers.add_parser("overview", help="Get file structure")
    p_overview.add_argument("file", help="File to analyze")

    # search
    p_search = subparsers.add_parser("search", help="Search with regex")
    p_search.add_argument("pattern", help="Regex pattern")
    p_search.add_argument("--glob", "-g", help="File glob filter")

    # memory
    p_memory = subparsers.add_parser("memory", help="Memory operations with folder support")
    mem_sub = p_memory.add_subparsers(dest="memory_cmd")

    # list - with optional folder filter
    p_mem_list = mem_sub.add_parser("list", help="List memories (supports folder filter)")
    p_mem_list.add_argument("folder", nargs="?", help="Folder to filter (e.g., active/tasks, learnings)")
    p_mem_list.add_argument("--no-recursive", action="store_true", help="Don't include subfolders")

    # read
    p_mem_read = mem_sub.add_parser("read", help="Read a memory")
    p_mem_read.add_argument("name", help="Memory name/path (e.g., active/tasks/HMKG-2064)")

    # write - supports nested paths
    p_mem_write = mem_sub.add_parser("write", help="Write a memory (folders auto-created)")
    p_mem_write.add_argument("name", help="Memory name/path (e.g., active/tasks/new_task)")
    p_mem_write.add_argument("content", nargs="?", default="-", help="Content (- for stdin)")
    p_mem_write.add_argument("--no-timestamp", action="store_true", help="Don't add timestamp")

    # delete
    p_mem_del = mem_sub.add_parser("delete", help="Delete a memory")
    p_mem_del.add_argument("name", help="Memory name/path")

    # tree - show folder structure
    p_mem_tree = mem_sub.add_parser("tree", help="Show memory folder structure")
    p_mem_tree.add_argument("folder", nargs="?", help="Start from subfolder")

    # search - search content
    p_mem_search = mem_sub.add_parser("search", help="Search memory contents (regex)")
    p_mem_search.add_argument("pattern", help="Regex pattern to search for")
    p_mem_search.add_argument("--folder", "-f", help="Limit search to folder")

    # archive - move to archive with date
    p_mem_archive = mem_sub.add_parser("archive", help="Archive memory (moves to archive/YYYY-MM/)")
    p_mem_archive.add_argument("name", help="Memory to archive")
    p_mem_archive.add_argument("--category", "-c", help="Category subfolder (e.g., tasks, sessions)")

    # mv - move/rename
    p_mem_mv = mem_sub.add_parser("mv", help="Move/rename a memory")
    p_mem_mv.add_argument("source", help="Source memory path")
    p_mem_mv.add_argument("dest", help="Destination path")

    # init - initialize folder structure
    p_mem_init = mem_sub.add_parser("init", help="Initialize recommended folder structure")
    p_mem_init.add_argument("--no-templates", action="store_true", help="Skip template files")

    # stats - show statistics
    mem_sub.add_parser("stats", help="Show memory statistics")

    # edit
    p_edit = subparsers.add_parser("edit", help="Symbol-based editing")
    edit_sub = p_edit.add_subparsers(dest="edit_cmd")

    p_replace = edit_sub.add_parser("replace", help="Replace symbol body")
    p_replace.add_argument("symbol", help="Symbol path")
    p_replace.add_argument("file", help="File path")
    p_replace.add_argument("body", nargs="?", default="-", help="New body (- for stdin)")

    p_after = edit_sub.add_parser("after", help="Insert after symbol")
    p_after.add_argument("symbol", help="Symbol path")
    p_after.add_argument("file", help="File path")
    p_after.add_argument("body", nargs="?", default="-", help="Code to insert")

    p_before = edit_sub.add_parser("before", help="Insert before symbol")
    p_before.add_argument("symbol", help="Symbol path")
    p_before.add_argument("file", help="File path")
    p_before.add_argument("body", nargs="?", default="-", help="Code to insert")

    p_rename = edit_sub.add_parser("rename", help="Rename symbol")
    p_rename.add_argument("symbol", help="Symbol path")
    p_rename.add_argument("file", help="File path")
    p_rename.add_argument("new_name", help="New name")

    # recipe
    p_recipe = subparsers.add_parser("recipe", help="Pre-built common operations")
    p_recipe.add_argument("recipe_name", nargs="?", default="list",
                          help="Recipe: entities, controllers, services, interfaces, tests, listeners, commands")

    # tools
    subparsers.add_parser("tools", help="List Serena tools")

    # status
    subparsers.add_parser("status", help="Check connection")

    # activate
    p_activate = subparsers.add_parser("activate", help="Activate a project")
    p_activate.add_argument("project", nargs="?", default=None,
                            help="Project path or name (defaults to current directory)")

    # projects
    subparsers.add_parser("projects", help="List registered projects")

    args = parser.parse_args()
    out = Output(json_mode=args.json)

    if not args.command:
        parser.print_help()
        sys.exit(0)

    try:
        if args.command == "find":
            cmd_find(args, out)
        elif args.command == "refs":
            cmd_refs(args, out)
        elif args.command == "overview":
            cmd_overview(args, out)
        elif args.command == "search":
            cmd_search(args, out)
        elif args.command == "memory":
            if not args.memory_cmd:
                print("Usage: serena memory {list|read|write|delete}")
                sys.exit(1)
            cmd_memory(args, out)
        elif args.command == "edit":
            if not args.edit_cmd:
                print("Usage: serena edit {replace|after|before|rename}")
                sys.exit(1)
            cmd_edit(args, out)
        elif args.command == "recipe":
            cmd_recipe(args, out)
        elif args.command == "tools":
            cmd_tools(args, out)
        elif args.command == "status":
            cmd_status(args, out)
        elif args.command == "activate":
            cmd_activate(args, out)
        elif args.command == "projects":
            cmd_projects(args, out)
        else:
            parser.print_help()
    except Exception as e:
        out.error(str(e))


if __name__ == "__main__":
    main()
